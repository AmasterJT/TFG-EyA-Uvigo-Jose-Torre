
\section{Diseño del sistema}
\label{sec:diseno}

En este capítulo se describe el diseño del sistema desarrollado, detallando la estructura general del sistema, la estructura de sus distintos componentes y clases, asi como las decisiones adoptadas para implementar cada una de las funcionalidades. El objetivo de este capítulo es definir cómo se materializan, desde un punto de vista técnico, los requisitos identificados en la sección \ref{subsec:requisitos}, sirviendo de base para la posterior fase de implementación.

\subsection{Arquitectura general del sistema}
\label{subsec:arquitectura-general}

El sistema ha sido diseñado siguiendo una arquitectura distribuida de tipo cliente-servidor, en la que los estaciones de trabajo fijas y telefonos móviles (clientes) interactúan con el servidor central.

La aplicación está compuesta por tres elementos principales: una aplicación de escritorio, una aplicación móvil Android y un servidor central MySQL que contiene la base de datos. Ambos clientes operan dentro de una red interna privada del almacén, lo que permite un entorno controlado desde el punto de vista de seguridad y acceso.

La aplicación de escritorio está destinada a la gestión y administración del sistema. En ella se podrá generar algunos fiheros necesarios para la realización de los envíos (Etiquetas de los palets) o bien para la gestion administrativa (información del sistema en formato excel) que podrán ser tratados posteriormente por otros sistemas externos.

La aplicación móvil Android se comunica con el servidor mediante una API de tipo REST, mientras que la aplicación de escritorio establece una conexión directa con la base de datos. Esta separación responde a criterios de simplicidad, rendimiento y adecuación al entorno operativo de cada dispositivo que empleamos como cliente.

\begin{figure}[H]
\centering
  \includegraphics[width=0.6\textwidth]{../Diagramas-UML/despliegue/despliegue.png}
  \caption{Arquitectura general del sistema cliente-servidor}
  \label{fig:arquitectura-general}
\end{figure}


\subsection{Diseño de la aplicación Desktop}
\label{subsec:diseno-desktop}

La aplicación de escritorio se ha diseñado en torno a una ventana principal que actúa como punto central de interacción con el sistema. Desde esta vista principal se proporciona acceso a las diferentes funcionalidades operativas y de gestión mediante. Las funcionalidades accesibles desde la ventana principal son las siguientes:

\begin{itemize}
    \item \textbf{Almacén}: Representación visual 3D del almacén con filtros aplicables (pestaña por defecto).
    \item \textbf{Inventario}: Consulta del inventario de palets.
    \item \textbf{Ver pedidos}: Asignación de pedidos a los diferentes usuarios.
    \item \textbf{Paletizar}: Ejecución de los pedidos en curso asignados a los usuarios.
    \item \textbf{Envíos}: Gestión de envíos de pedidos.
    \item \textbf{Calendario}: Visualización del calendario de operaciones y eventos. 
\end{itemize}

Determinadas acciones se ejecutan directamente dentro de la ventana principal, mientras que otras se gestionan a través de ventanas secundarias específicas. Estas ventanas emergentes están orientadas a tareas concretas que requieren un flujo de trabajo independiente, como la generación de órdenes de compra o la administración de usuarios (creación, modificación y eliminación), entre otros. Esta organización permite mantener una interfaz clara y evitar la sobrecarga de información en la vista principal. Estas ventanas son:

\begin{itemize}
    \item \textbf{Movimiento de palets}: Pertmite tanto transladar un palet de un aubicación a otra como registrar la entrada o salida de un palet del almacén.
    \item \textbf{Actualizar palets}: Modifica la cantidad de producto dentro de un palet existente, así como sus dimensiones físicas.
    \item \textbf{Orden compra}: Crea una solicitud de compra de productos en la base de datos.
     \item \textbf{Export}: Exporta la información del inventario o de los pedidos a un fichero Excel.
    \item \textbf{Crear pedido}: Genera un nuevo pedido en la base de datos.
    \item \textbf{Editar pedido}: Modifica un pedido existente.
    \item \textbf{Eliminar pedido}: Elimina un pedido existente.
    \item \textbf{Crear usuario}: Genera un nuevo usuario en la base de datos.
    \item \textbf{Editar usuario}: Modifica un usuario existente.
    \item \textbf{Eliminar usuario}: Elimina un usuario existente.
    \item \textbf{Crear tipo}: Crea un nuevo tipo de producto en la base de datos.
    \item \textbf{Crear producto}: Genera un nuevo producto en la base de datos, con la información por defecto proveniente del proveedor.
    \item \textbf{Enviar pedidos}: Selección del transportista para el envio.
    \item \textbf{Detalle pedidos}: Visualización detallada de los pedidos a realizar.
\end{itemize}

Desde el punto de vista estructural, la aplicación se ha diseñado siguiendo una separación clara de responsabilidades entre la capa de presentación y la capa de acceso a datos. La capa de presentación, implementada mediante JavaFX, se encarga de la gestión de la interfaz gráfica y de la interacción con el usuario, mientras que la capa de acceso a datos centraliza la comunicación con la base de datos mediante el uso del conector MySQL.

\textbf{Nota}: La aplicación de escritorio no realiza compras a proveedores externos, sino que se limita a la generación de órdenes de compra que deben ser gestionadas posteriormente por el departamento correspondiente.



\begin{figure}[H]
\centering
  \includegraphics[width=1\textwidth]{Imagenes/diagrama-navegacion-ventanas.png}
  \caption{Diagrama de navegación entre ventanas de la aplicación Desktop}
  \label{fig:diagrama-navegacion-ventanas}
\end{figure}

A continuación, en la Figura~\ref{fig:ejemplo-arquitectura-general} se muestra un ejemplo de navegación entre ventanas de la aplicación Desktop, desde la ventana de \textit{Login} hasta la ventana de \textit{Orden Compras} pasando por la ventana principal \textit{Almacén}.

\begin{figure}[H]
\centering
  \includegraphics[width=1\textwidth]{Imagenes/ejemplo-navegacion-ventanas.png}
  \caption{Ejemplo de navegación entre ventanas de la aplicación Desktop (desde \textit{Login} hasta \textit{Orden Compras})}
  \label{fig:ejemplo-navegacion-ventanas}
\end{figure}



\subsection{Diseño de la aplicación Android}
\label{subsec:diseno-android}

La aplicación móvil Android ha sido diseñada como una herramienta de apoyo a la operativa en planta, orientada principalmente a los operarios del almacén. Su diseño prioriza la simplicidad de uso y el acceso rápido a la información relevante durante la ejecución de los pedidos por parte de los operarios.

La aplicación actúa como un cliente que delega la lógica de negocio en el servidor, comunicándose con este mediante una API REST. De este modo, la aplicación móvil se limita a gestionar la interfaz de usuario y el envío y recepción de datos.

La función de esta aplicación es la de permitir a los operarios ejecutar movimientos de palets y apoyar en la ejecución de pedidos, todo ello desde dispositivos móviles que facilitan su uso en el entorno del almacén. En particular, esta aplicación es un subapartado de la aplicación de escritorio combinando las funcionalidades de las pestañas de \textit{Paletizar} y \textit{Actualizar de palets}, permitiendo asi la correcta ejecución de los pedidos.


\begin{figure}[H]
\centering
  \includegraphics[width=0.6\textwidth]{Imagenes/diagrama-navegacion-ventanas-android.png}
  \caption{Diagrama de navegación entre ventanas de la aplicación Android}
  \label{fig:adiagrama-navegacion-android}
\end{figure}


% A continuación, en la Figura~\ref{fig:ejemplo-navegacion-ventanas-android} se muestra un ejemplo de navegación entre ventanas de la aplicación Android, desde la activity de \textit{Login} hasta la activity de \textit{Paletizar} pasando por la ventana activity \textit{Ventana principal} y la activity \textit{Gestióin Pedidos}.

\begin{figure}[H]
\centering
  \includegraphics[width=0.8\textwidth]{Imagenes/ejemplo-navegacion-ventanas-android.png}
  \caption{Ejemplo de navegación entre ventanas de la aplicación Android (desde \textit{Login} hasta \textit{Paletizar})}
  \label{fig:ejemplo-navegacion-ventanas-android}
\end{figure}




\subsection{Diseño de la base de datos}
\label{subsec:diseno-bd}

La base de datos constituye el núcleo de persistencia del sistema y ha sido diseñada para dar soporte directo a las operaciones propias de un almacén de consolidación. El modelo de datos representa de forma explícita los principales elementos del dominio, incluyendo productos, tipos de producto, palets, ubicaciones, pedidos, detalles del pedido, usuarios y roles, entre otros.

El diseño se ha basado en un modelo relacional normalizado (\gls{base de datos relacional}). Cada entidad se implementa mediante una tabla independiente identificada por una clave primaria, lo que permite un acceso unívoco a los registros y facilita su referenciación desde otras tablas. Las relaciones entre entidades se modelan mediante claves foráneas, reflejando dependencias como la asignación de palets a ubicaciones concretas, la composición de los pedidos mediante líneas asociadas a productos o el registro de movimientos vinculados a palets específicos. Este enfoque garantiza la integridad referencial y evita la duplicación innecesaria de información.

A nivel de esquema se han definido restricciones explícitas para reforzar la coherencia de los datos almacenados. En primer lugar, se han establecido campos obligatorios (\texttt{NOT NULL}) en atributos críticos del sistema, como el código SKU y la descripción de los productos, la ubicación asociada a cada palet, el estado de los pedidos o el identificador del usuario responsable de determinadas operaciones. Estas restricciones impiden la inserción de registros incompletos que podrían comprometer la operativa del almacén.

Asimismo, se han aplicado restricciones de unicidad (\texttt{UNIQUE}) en aquellos atributos que deben identificar de forma inequívoca una entidad dentro del sistema. Entre estos se incluyen el nombre de usuario utilizado para la autenticación, el código SKU de los productos y determinados identificadores internos de pedidos y palets. De este modo se evitan duplicidades que podrían generar inconsistencias, errores en los procesos de gestión o ambigüedad en la identificación de los elementos del almacén.

Las relaciones de dependencia entre entidades se controlan mediante claves foráneas (\texttt{FOREIGN KEY}), asegurando, por ejemplo, que un palet solo pueda estar asociado a una ubicación existente, que las líneas de pedido referencien productos previamente registrados o que los movimientos de almacén correspondan a palets válidos. Estas restricciones impiden la eliminación o modificación de registros que estén siendo utilizados por otras tablas, evitando la aparición de estados inconsistentes dentro de la base de datos.

En lo relativo a la seguridad, el diseño de la base de datos contempla específicamente la protección de las credenciales de los usuarios. Las contraseñas no se almacenan en texto claro, sino como valores derivados mediante un algoritmo de hash criptográfico. Para ello se ha empleado Argon2, un algoritmo de derivación de claves diseñado específicamente para el almacenamiento seguro de contraseñas. Este algoritmo permite configurar parámetros de coste en memoria y tiempo de cómputo, proporcionando resistencia frente a ataques de fuerza bruta y ataques basados en hardware especializado, y alineando el sistema con las buenas prácticas de seguridad en aplicaciones de gestión.

El script completo de creación del esquema se incluye en el Anexo \ref{anexo:sql-esquema}. Para entender bien los distintos símbolos que aparecen en los campos de las tablas y las lineas que representan las relaciones entre las tablas del diagrama EER se debe consultar el Anexo \ref{anexo:simbolos-eer}.


\begin{figure}[H]
\centering
  \includegraphics[width=1\textwidth]{Imagenes/diagrama-EER.png}
  \caption{Diagrama Entidad-Relación (EER) del sistema de gestión de almacén}
  \label{fig:diagrama-eer}
\end{figure}

\begingroup
\sloppy
\subsubsection{Gestión de usuarios, roles y permisos}

\paragraph{Tabla \texttt{roles}.}
Define los perfiles de acceso del sistema. Su clave primaria es \texttt{id\_rol}. Se referencia desde \texttt{usuarios} mediante \texttt{id\_rol}.

\paragraph{Tabla \texttt{permisos\_usuarios}.}
Catálogo de permisos/funcionalidades controladas por rol. La clave primaria es \texttt{id\_permiso}. El campo \texttt{nombre\_permiso} es \texttt{UNIQUE}, evitando duplicidades en el identificador lógico del permiso.

\paragraph{Tabla \texttt{rol\_permiso}.}
Tabla de asociación rol--permiso. Implementa una relación N:M entre \texttt{roles} y \texttt{permisos\_usuarios}. Su clave primaria es compuesta: \texttt{(id\_rol, id\_permiso)}. Incluye el campo \texttt{estado} (p.\,ej. \texttt{activo}, \texttt{inactivo}, \texttt{ver}) para modelar el nivel de acceso concedido por cada rol a cada permiso.
Define dos claves foráneas:
\texttt{id\_rol} $\rightarrow$ \texttt{roles(id\_rol)} y
\texttt{id\_permiso} $\rightarrow$ \texttt{permisos\_usuarios(id\_permiso)}.

\paragraph{Tabla \texttt{usuarios}.}
Almacena la identidad y credenciales de acceso. La clave primaria es \texttt{id\_usuario}. Los campos \texttt{nombre}, \texttt{apellido1}, \texttt{apellido2} y \texttt{email} están definidos como \texttt{NOT NULL}; \texttt{email} es \texttt{UNIQUE}. El campo \texttt{contraseña} (\texttt{VARCHAR(255)}) almacena el \emph{hash} de contraseña (Argon2), evitando el almacenamiento en texto plano.
La relación con roles se implementa mediante \texttt{id\_rol} como clave foránea a \texttt{roles(id\_rol)} con \texttt{ON DELETE CASCADE} y \texttt{ON UPDATE CASCADE}.
Incluye \texttt{fecha\_registro} con \texttt{DEFAULT CURRENT\_TIMESTAMP}.

\paragraph{Trigger \texttt{generar\_user\_name}.}
Trigger \texttt{BEFORE INSERT} sobre \texttt{usuarios}. Genera automáticamente \texttt{user\_name} concatenando la inicial del nombre y fragmentos de apellidos, y añade un sufijo hexadecimal en función del número de coincidencias existentes; también inicializa \texttt{activo=1}. Este trigger evita dependencias del cliente para construir el identificador de usuario.

\subsubsection{Catálogo de productos y proveedores}

\paragraph{Tabla \texttt{tipos}.}
Catálogo de tipos de producto. Clave primaria \texttt{id\_tipo}. El campo \texttt{nombre} es \texttt{UNIQUE}, imponiendo unicidad del tipo a nivel de esquema.

\paragraph{Tabla \texttt{proveedores}.}
Almacena proveedores. Clave primaria \texttt{id\_proveedor}. El campo \texttt{nombre\_proveedor} es \texttt{UNIQUE} para evitar duplicidades de proveedor en el catálogo.

\paragraph{Tabla \texttt{productos}.}
Define el maestro de producto. Clave primaria \texttt{id\_producto}.
Incluye \texttt{identificador\_producto} como clave lógica \texttt{UNIQUE} (referencia interna/externa estable para integraciones y trazabilidad). \texttt{nombre} y \texttt{cantidad\_por\_palet} están marcados como \texttt{NOT NULL}.
Relaciona el producto con su tipo mediante la clave foránea \texttt{id\_tipo} $\rightarrow$ \texttt{tipos(id\_tipo)}.

\paragraph{Tabla \texttt{proveedor\_producto}.}
Materializa la relación N:M entre \texttt{proveedores} y \texttt{productos}, permitiendo registrar la asociación de un proveedor con un producto concreto. Clave primaria compuesta \texttt{(id\_proveedor, id\_producto)}. Define dos claves foráneas:
\texttt{id\_proveedor} $\rightarrow$ \texttt{proveedores(id\_proveedor)} y
\texttt{id\_producto} $\rightarrow$ \texttt{productos(id\_producto)}.

\subsubsection{Estructura física del almacén, ubicaciones y palets}

\paragraph{Tabla \texttt{estanterias}.}
Representa una estantería física. Clave primaria \texttt{id\_estanteria}. Incluye \texttt{nombre\_estanteria} y parámetros geométricos/capacidad: \texttt{num\_baldas}, \texttt{num\_posiciones\_balda}, \texttt{posiciones\_total}, \texttt{posiciones\_disponibles}. El campo \texttt{nombre\_estanteria} es \texttt{UNIQUE}.

\paragraph{Trigger \texttt{calcular\_posiciones\_disponibles}.}
Trigger \texttt{BEFORE INSERT} sobre \texttt{estanterias}. Calcula \texttt{posiciones\_total} y \texttt{posiciones\_disponibles} como producto de \texttt{num\_baldas} por \texttt{num\_posiciones\_balda}. Con ello se evita inconsistencia entre capacidad declarada y capacidad derivada.

\paragraph{Tabla \texttt{ubicaciones}.}
Modela la ubicación física concreta dentro de una estantería. Clave primaria \texttt{id\_ubicacion}. Incluye \texttt{balda}, \texttt{posicion} y \texttt{delante} (profundidad/posición frontal-trasera). Se asocia a una estantería mediante la clave foránea \texttt{id\_estanteria} $\rightarrow$ \texttt{estanterias(id\_estanteria)} con \texttt{ON DELETE CASCADE} y \texttt{ON UPDATE CASCADE}.
Impone unicidad lógica de la coordenada física mediante \texttt{UNIQUE(id\_estanteria, balda, posicion, delante)}, evitando crear dos ubicaciones idénticas dentro de la misma estantería.

\paragraph{Tabla \texttt{palets}.}
Entidad central de inventario: cada registro representa un palet identificado por \texttt{id\_palet}. Contiene datos dimensionales (\texttt{alto}, \texttt{ancho}, \texttt{profundo}), \texttt{peso} y \texttt{cantidad\_producto}.
Se asocia a producto mediante \texttt{identificador\_producto} como clave foránea a \texttt{productos(identificador\_producto)} y a ubicación mediante \texttt{id\_ubicacion} como clave foránea a \texttt{ubicaciones(id\_ubicacion)}.
La restricción \texttt{UNIQUE(id\_ubicacion)} garantiza ocupación 1:1 (una ubicación no puede contener más de un palet simultáneamente en el modelo).

\subsubsection{Pedidos, detalle y expedición}

\paragraph{Tabla \texttt{clientes}.}
Datos del cliente destinatario de pedidos. Clave primaria \texttt{id\_cliente}. Los campos \texttt{nif} y \texttt{nombre\_cliente} están definidos como \texttt{NOT NULL}.

\paragraph{Tabla \texttt{transportistas}.}
Catálogo de transportistas. Clave primaria \texttt{id\_transportista}. El campo \texttt{nombre\_transportista} es \texttt{NOT NULL}.

\paragraph{Tabla \texttt{pedidos}.}
Cabecera de pedido. Clave primaria \texttt{id\_pedido}. Incluye \texttt{fecha\_creacion} con \texttt{DEFAULT CURRENT\_TIMESTAMP} y el campo \texttt{estado} como \texttt{ENUM('pendiente','en\_proceso','completado','enviado','cancelado')} para restringir estados válidos.
Relaciona el pedido con:
\texttt{usuarios(id\_usuario)} (usuario responsable/asignado),
\texttt{clientes(id\_cliente)} (destinatario),
\texttt{transportistas(id\_transportista)} (expedición; admite \texttt{NULL} hasta asignación).
Incluye \texttt{codigo\_referencia} como identificador operativo \texttt{UNIQUE}.

\paragraph{Trigger \texttt{generar\_codigo\_referencia}.}
Trigger \texttt{BEFORE INSERT} sobre \texttt{pedidos}. Genera \texttt{codigo\_referencia} con formato \texttt{YYYYMMDD-XXX}, donde \texttt{XXX} es un contador diario en hexadecimal (\texttt{LPAD(HEX(...),3,'0')}). Asegura unicidad por día sin depender del cliente.

\paragraph{Tabla \texttt{detalles\_pedido}.}
Líneas de pedido. Clave primaria \texttt{id\_detalle\_pedido}. Define \texttt{cantidad} como \texttt{NOT NULL}.
Implementa la composición del pedido mediante dos claves foráneas:
\texttt{id\_pedido} $\rightarrow$ \texttt{pedidos(id\_pedido)} y
\texttt{id\_producto} $\rightarrow$ \texttt{productos(id\_producto)}.

\paragraph{Tabla \texttt{palet\_salida}.}
Tabla de enlace entre \texttt{palets} y \texttt{pedidos} para registrar qué palets se asocian a la expedición de un pedido. Clave primaria \texttt{id\_palet\_salida}.
Define claves foráneas:
\texttt{id\_palet} $\rightarrow$ \texttt{palets(id\_palet)} y
\texttt{id\_pedido} $\rightarrow$ \texttt{pedidos(id\_pedido)}.



\subsubsection{Órdenes de compra}

\paragraph{Tabla \texttt{orden\_compra}.}
Cabecera de orden de compra. Clave primaria \texttt{id\_oc}. Incluye \texttt{fecha\_creacion} con \texttt{DEFAULT CURRENT\_TIMESTAMP}, \texttt{estado} como \texttt{ENUM} \texttt{(`pendiente',`tramitada',`cancelada')} y \texttt{codigo\_oc} como identificador \texttt{UNIQUE}.
Cabecera de orden de compra. Clave primaria \texttt{id\_oc}. Incluye \texttt{fecha\_creacion} con \texttt{DEFAULT CURRENT\_TIMESTAMP}, \texttt{estado} como \texttt{ENUM('pendiente','tramitada','cancelada')} y \texttt{codigo\_oc} como identificador \texttt{UNIQUE}.
Asocia la orden con un proveedor mediante \texttt{id\_proveedor} como clave foránea a \texttt{proveedores(id\_proveedor)}.

\paragraph{Trigger \texttt{generar\_codigo\_orden\_compra}.}
Trigger \texttt{BEFORE INSERT} sobre \texttt{orden\_compra}. Genera \texttt{codigo\_oc} con formato \texttt{OC-YYYYMMDD-XXX}, usando un contador diario en hexadecimal para garantizar unicidad operativa.

\paragraph{Tabla \texttt{detalle\_orden\_compra}.}
Líneas de una orden de compra. Clave primaria \texttt{id\_detalle}. Contiene \texttt{cantidad} como \texttt{NOT NULL}.
Define claves foráneas:
\texttt{id\_oc} $\rightarrow$ \texttt{orden\_compra(id\_oc)} y
\texttt{id\_producto} $\rightarrow$ \texttt{productos(id\_producto)}.
\endgroup


\clearpage
\subsection{Diseño de la API}
\label{subsec:diseno-api}

La \gls{api} del sistema se ha diseñado como una aplicación REST, actuando como capa intermedia entre la aplicación móvil Android y el sistema de persistencia. Su objetivo principal es exponer de forma controlada el modelo de datos del almacén y encapsular la lógica de negocio asociada a la gestión de palets, ubicaciones y demás elementos operativos.

Desde el punto de vista arquitectónico, la \gls{api} sigue una estructura en capas claramente diferenciadas, compuesta por una capa de controladores, una capa de servicios y una capa de acceso a datos. Esta organización permite separar responsabilidades, reducir el acoplamiento entre componentes y facilitar tanto el mantenimiento como la evolución del sistema.

La \textbf{capa de presentación} está formada por controladores REST que exponen los distintos endpoints \gls{http} y gestionan la entrada y salida de datos en formato JSON. Estos controladores se encargan de validar las peticiones recibidas, delegar el procesamiento en la capa de servicios y devolver respuestas con códigos \gls{http} adecuados según el resultado de la operación, como respuestas de éxito, errores de validación, recursos no encontrados o conflictos de estado.

La \textbf{capa de servicio} concentra la lógica de negocio del sistema. En ella se implementan las reglas que gobiernan el funcionamiento del almacén, como la validación de ubicaciones disponibles, la prevención de colisiones entre palets o la coherencia de los movimientos registrados. Los servicios orquestan el acceso a los repositorios y gestionan operaciones que pueden implicar varias acciones sobre la base de datos, utilizando transacciones para garantizar la consistencia de los datos.

La \textbf{capa de acceso a datos} se apoya en Spring Data JPA y está compuesta por repositorios que extienden interfaces del tipo \texttt{JpaRepository}. Esta capa proporciona las operaciones básicas de persistencia y permite definir consultas adicionales mediante el uso de métodos derivados por nombre. Por ejemplo, se emplean métodos específicos para comprobar si una ubicación ya está ocupada por otro palet antes de permitir su creación o movimiento, evitando estados inconsistentes en la base de datos.

El modelo de datos expuesto por la \gls{api} se basa en entidades JPA que representan los elementos principales del almacén, como palets, estanterías, baldas y ubicaciones. Para desacoplar la representación interna del sistema de la información intercambiada con los clientes, se utilizan objetos de transferencia de datos (DTOs). Estos DTOs permiten controlar los campos expuestos en cada operación y facilitan la validación de los datos recibidos.

La \gls{api} hace uso de validaciones declarativas mediante anotaciones estándar, garantizando que los datos recibidos cumplan los requisitos definidos antes de ser procesados. Los errores y excepciones generados durante la ejecución se gestionan de forma centralizada, transformándolos en respuestas estructuradas que incluyen información clara sobre la causa del fallo.

En cuanto a la interacción con los telefonos Android, la \gls{api} define endpoints REST semánticos que siguen las convenciones habituales del protocolo \gls{http}, incluyendo operaciones de consulta, creación, actualización y eliminación de recursos. Se emplean códigos de estado \gls{http} para reflejar correctamente el resultado de cada operación y, cuando es necesario, se admite el uso de paginación y filtrado mediante parámetros de consulta.

Este diseño permite que la \gls{api} actúe como un componente independiente, reutilizable y fácilmente ampliable, proporcionando un punto de acceso controlado a la información del almacén y garantizando la coherencia de las operaciones realizadas desde la aplicación móvil Android.


\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=0.8\textwidth]{../Diagramas-UML/api-componentes-capas/api-componentes-capas.png}%
}
\caption{Arquitectura en capas de la API REST}
\label{fig:arquitectura-api}
\end{figure}

















\subsection{Diagramas UML}
\label{subsec:uml}

Para representar de forma gráfica la estructura y el comportamiento del sistema, se han empleado distintos diagramas UML.


\subsubsection{Diagrama de clases}
\label{subsubsec:uml-clases}

El diagrama de clases representa las principales entidades del sistema, sus atributos y las relaciones existentes entre ellas. Este diagrama sirve como referencia para el diseño del modelo de datos y para la implementación de la lógica del sistema.


En la Figura~\ref{fig:diagrama-clases-dektop} se representa el diagrama de clases correspondiente a la aplicación de escritorio. Este diagrama se centra en las entidades del dominio del almacén, como productos, palets, pedidos, movimientos y usuarios, así como en las relaciones que reflejan los procesos operativos del sistema. 


\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=0.9\textwidth]{../Diagramas-UML/diagrama-clases-desktop/diagrama-clases-desktop.png}%
}
\caption{Diagrama de clases del sistema desktop}
\label{fig:diagrama-clases-dektop}
\end{figure}


Por otra parte, la Figura~\ref{fig:diagrama-clases-android} muestra una vista del diagrama de clases de la aplicación Android. Se muestra la estructura de la capa cliente, destacando las actividades principales de la interfaz, los clientes de comunicación con la API REST y los objetos de transferencia de datos (DTOs).


\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=1\textwidth]{../Diagramas-UML/diagrama-clases-android/diagrama-clases-android.png}%
}
\caption{Diagrama de clases del sistema android}
\label{fig:diagrama-clases-android}
\end{figure}


\subsubsection{Diagrama de secuencia}
\label{subsubsec:uml-secuencia}

Los diagramas de secuencia permiten representar de forma temporal y ordenada las interacciones entre los distintos componentes del sistema durante la ejecución de determinados casos de uso.

En este trabajo se han seleccionado algunos diagramas de secuencia representativos, que ilustran procesos clave del sistema, se reprsentan un porceso interno de la aplicación (login), el proceso principal de gestión de pedidos y un proceso interno del almacen de modificación de cantidad de palet.

El primer diagrama de secuencia describe el proceso de autenticación de usuarios, haciendo especial énfasis en el tratamiento seguro de las credenciales. En este flujo se representa cómo la aplicación cliente envía los datos de acceso, cómo el sistema verifica la contraseña mediante su comparación con el valor almacenado en forma de hash utilizando el algoritmo Argon2, y cómo se gestiona la respuesta de autenticación en función del resultado de la validación.

\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=0.9\textwidth]{../Diagramas-UML/login/login.png}%
}
\caption{Diagrama de secuencia de inicio de sesión}
\label{fig:diagrama-login}
\end{figure}

El segundo diagrama de secuencia muestra el flujo completo asociado a la gestión de un pedido, desde su asignación inicial hasta su envío. Este diagrama refleja las interacciones entre los distintos componentes del sistema durante la consulta del pedido, su preparación, la actualización de su estado y la confirmación final del envío, proporcionando una visión clara del ciclo de vida de un pedido dentro del sistema.

\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=1\textwidth]{../Diagramas-UML/diagrama-gestion-pedidos/diagrama-gestion-pedidos.png}%
}
\caption{Diagrama de secuencia de gestión de pedidos}
\label{fig:diagrama-gestion-pedidos}
\end{figure}

A continuación se presenta un diagrama de secuencia que describe el flujo de interacción necesario para modificar la cantidad de producto asociada a un palet existente.

\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=0.9\textwidth]{../Diagramas-UML/diagrama-modificar-cantidad-palet/diagrama-modificar-cantidad-palet.png}%
}
\caption{Diagrama de secuencia de modificación de cantidad de palet}
\label{fig:diagrama-modificar-cantidad-palet}
\end{figure}



\subsubsection{Diagrama de despliegue}
\label{subsubsec:uml-despliegue}

El diagrama de despliegue describe la distribución física de los componentes del sistema en tiempo de ejecución y su asignación a los distintos nodos de la infraestructura. En él se representan las estaciones de trabajo que ejecutan la aplicación de escritorio, los dispositivos móviles que ejecutan la aplicación Android, el servidor que aloja el backend y el servidor de base de datos. Asimismo, se especifican los enlaces de comunicación entre estos nodos, indicando el protocolo utilizado y el formato de los datos intercambiados.

En el sistema desarrollado se distinguen dos tipos de acceso a la información en función del tipo de cliente. Por un lado, la aplicación de escritorio, instalada en equipos ubicados dentro de la red interna del almacén, establece una conexión directa con el servidor de base de datos MySQL mediante JDBC. Por otro lado, la aplicación Android se comunica exclusivamente con el backend implementado con Spring Boot a través de una API REST sobre HTTPS, intercambiando mensajes en formato JSON. El backend actúa como intermediario entre la aplicación móvil y la base de datos, accediendo a esta última también mediante JDBC.

Este diagrama permite justificar decisiones arquitectónicas relevantes, como la separación del backend para los clientes móviles, el uso de distintos canales de comunicación según el entorno de ejecución y la limitación del acceso directo a la base de datos a un conjunto reducido de aplicaciones en un entorno controlado. Además, se reflejan elementos auxiliares del sistema, como la generación de ficheros de exportación y el envío de documentos que serán consumidos por dispositivos exrternos como impresoras..

\paragraph{Supuestos de red}
El sistema está diseñado para operar dentro de la red interna del almacén, sin necesidad de acceso desde redes externas.


\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=0.8\textwidth]{../Diagramas-UML/diagrama-despliegue/diagrama-despliegue.png}%
}
\caption{Diagrama de despliegue del sistema}
\label{fig:diagrama-despliegue}
\end{figure}



\subsection{Diseño de la interfaz de usuario}
\label{subsec:diseno-ui}

El diseño de la interfaz de usuario se ha definido a partir de los requisitos funcionales del sistema y de los distintos perfiles de usuario identificados en el análisis. El objetivo principal ha sido garantizar una interacción clara, consistente y alineada con el contexto operativo de un almacén de consolidación.

En la aplicación de escritorio, orientada a usuarios con funciones de supervisión y administración, la interfaz se estructura en torno a una ventana principal que centraliza el acceso a las funcionalidades del sistema. La disposición de menús y botones responde a una organización funcional, agrupando las operaciones relacionadas con inventario, pedidos, movimientos y administración. Se prioriza la visualización estructurada de grandes volúmenes de información mediante tablas, vistas detalladas y paneles específicos, permitiendo al usuario mantener una visión global del estado del almacén y acceder a operaciones avanzadas.

Las ventanas secundarias se utilizan para acciones que requieren un flujo de trabajo independiente, como la creación y edición de pedidos, la gestión de usuarios o la actualización de información de palets. Esta separación evita la sobrecarga de la vista principal y reduce el riesgo de errores derivados de la ejecución simultánea de tareas no relacionadas.

A continuación se muestra la ventana principal de la aplicación de escritorio en la Figura~\ref{fig:ventana-principal-desktop}.


\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=1\textwidth]{Imagenes/ventana-principal-desktop.png}%
}
\caption{Ventana principal de la aplicación de escritorio}
\label{fig:ventana-principal-desktop}
\end{figure}



% \begin{figure}[H]
% \centering
% \rotatebox{0}{%
%   \includegraphics[width=1\textwidth]{Imagenes/ventana-secundaria-movimiento-palets.jpg}
% }
% \caption{Ventana secundaria de movimiento de palets en la aplicación de escritorio}
% \label{fig:ventana-secundaria-movimiento-palets}
% \end{figure}


% \begin{figure}[H]
% \centering
% \rotatebox{0}{%
%   \includegraphics[width=1\textwidth]{Imagenes/ventana-secundaria-orden-compra.jpg}
% }
% \caption{Ventana secundaria de orden de compra en la aplicación de escritorio}
% \label{fig:ventana-secundaria-orden-compra}
% \end{figure}


% \begin{figure}[H]
% \centering
% \rotatebox{0}{%
%   \includegraphics[width=1\textwidth]{Imagenes/ventana-secundaria-export-data.jpg}
% }
% \caption{Ventana secundaria de exportación de datos en la aplicación de escritorio}
% \label{fig:ventana-secundaria-export-data}
% \end{figure}

las Figura~\ref{fig:ventanas-secundarias-desktop} y \ref{fig:ui-orden-compra} muestran algunas de las ventanas secundarias de la aplicación de escritorio, mostrando las diversas de tareas que pueden gestionarse desde estas ventanas especializadas.


\begin{figure}[H]
\centering

\begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{Imagenes/ventana-secundaria-movimiento-palets.jpg}
  \caption{Movimiento de palets}
  \label{fig:ui-movimiento-palets}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{Imagenes/ventana-secundaria-export-data.jpg}
  \caption{Exportación de datos}
  \label{fig:ui-export-data}
\end{subfigure}

\caption{Ventanas secundarias de la aplicación de escritorio}
\label{fig:ventanas-secundarias-desktop}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{Imagenes/ventana-secundaria-orden-compra.jpg}
\caption{Ventana de orden de compra}
\label{fig:ui-orden-compra}
\end{figure}




En la aplicación móvil Android, destinada principalmente a operarios, el diseño de la interfaz se ha orientado a la ejecución rápida y directa de acciones en el entorno del almacén. La navegación se basa en pantallas específicas para cada tarea, con un número reducido de elementos visibles y controles intuitivos. Las operaciones más frecuentes, como la actualización de las cantidades de los palets que se están manipulando, la consulta de pedidos asignados o el registro del contenido de los palets generados para el envío, se han diseñado para completarse con el mínimo número de interacciones posibles.



\begin{figure}[H]
\centering

\begin{subfigure}[t]{0.32\textwidth}
  \centering
  \includegraphics[width=0.87\textwidth]{Imagenes/ventana-principal-android.jpg}
  \caption{Ventana principal android}
  \label{fig:ui-ventana-principal-android}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.32\textwidth}
  \centering
  \includegraphics[width=0.87\textwidth]{Imagenes/ventana-actualizar-palet-android.jpg}
  \caption{Actualizar palet}
  \label{fig:ui-actualizar-palet-android}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.32\textwidth}
  \centering
  \includegraphics[width=0.87\textwidth]{Imagenes/ventana-paletizar-android.jpg}
  \caption{Paletización}
  \label{fig:ui-paletizar-android}
\end{subfigure}

\caption{Ventanas principales de la aplicación Android}
\label{fig:ventanas-secundarias-android}
\end{figure}