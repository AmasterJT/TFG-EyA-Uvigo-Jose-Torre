\section{Implementación}
\label{sec:implementacion}

\subsection{Herramientas y tecnologías utilizadas}
\label{subsec:herramientas}

El sistema desarrollado se ha implementado íntegramente utilizando el lenguaje de programación Java. Este lenguaje se ha empleado tanto en el desarrollo de la aplicación de escritorio como en la aplicación móvil Android y en el backend del sistema, implementado mediante el framework Spring Boot.

La utilización de un lenguaje común en todos los componentes de la solución facilita la integración entre las distintas aplicaciones, simplifica el mantenimiento del sistema y permite reutilizar conocimientos y conceptos a lo largo de todo el desarrollo. Además, Java es un lenguaje ampliamente utilizado en entornos industriales y empresariales, caracterizado por su portabilidad, robustez y amplio ecosistema de herramientas y librerías \cite{oracle_java}.


\begin{itemize}
    \item \textbf{Control de versiones}: Git.
    \item \textbf{Backend}: Java junto con el framework Spring Boot.
    \item \textbf{Base de datos}: MySQL.
    \item \textbf{Gestión y modelado de datos}: MySQL Workbench y Draw.io.
    \item \textbf{Desarrollo de la aplicación de escritorio}: IntelliJ IDEA Ultimate.
    \item \textbf{Desarrollo de la aplicación móvil}: Android Studio.
    \item \textbf{Pruebas de la API}: Postman.
    \item \textbf{Entorno de despliegue}: VMware Workstation con un servidor Ubuntu.
    \item \textbf{Gestión del proyecto}: Git.
\end{itemize}


\subsection{Implementación de la aplicación Desktop}
\label{subsec:impl-desktop}

La aplicación de escritorio se ha implementado en Java utilizando JavaFX para la construcción de la interfaz gráfica y \gls{jdbc}, mediante el conector oficial \textit{MySQL Connector}, para la comunicación directa con la base de datos relacional.

La estructura del proyecto se organiza en paquetes diferenciados según su función. La capa de interfaz de usuario agrupa los controladores JavaFX asociados a cada ventana o diálogo, encargados de gestionar los eventos de usuario y la actualización de la vista. La capa de acceso a datos encapsula las consultas \gls{sql} mediante clases \gls{dao}, responsables de ejecutar consultas parametrizadas y gestionar los resultados obtenidos a través de \gls{resultset}. Esta separación permite aislar la lógica de persistencia de la interfaz gráfica y facilita el mantenimiento del código.

La ventana principal constituye el punto de acceso a las funcionalidades del sistema y centraliza la navegación entre los distintos módulos de la aplicación, tales como la gestión del almacén, el inventario, los pedidos, la paletización, los envíos y el calendario de operaciones. Cada módulo se estructura a nivel de interfaz mediante ficheros \gls{fxml} específicos.

Para evitar la sobrecarga de visual de la ventana principal, se utilizan ventanas secundarias para determinadas operaciones (orden de compra, exportacion de datos, entre otras), cargadas dinámicamente a partir de ficheros \gls{fxml} independientes, así podemos realizar una interfaz gráfica más clara e intuitiva.


El control de acceso a funcionalidades se implementa en el cliente mediante comprobaciones del rol del usuario autenticado, habilitando o deshabilitando botones y opciones de menú en función de los permisos asignados. Las operaciones críticas se validan adicionalmente a nivel de base de datos, garantizando coherencia ante usos incorrectos de la interfaz, por ejemplo, la base de datos imposibilita introducir un palet en una posicion ya acupada o inexistente.

Finalmente, la aplicación incorpora mecanismos de exportación de datos a ficheros Excel y generación de documentos PDF para etiquetas y listados operativos, integrados directamente en el flujo de trabajo del usuario.

Las tecnologías empleadas en la implementación de la aplicación de escritorio, la Tabla~\ref{tab:deps-desktop-principales} recoge las dependencias principales utilizadas, junto con su versión y su función dentro del proyecto.

\begin{table}[H]
\centering
\small
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{m{4.2cm} m{2.2cm} m{7.6cm}}
\toprule
\rowcolor{gray!15}
\multicolumn{1}{c}{\textbf{Componente}} &
\multicolumn{1}{c}{\textbf{Versión}} &
\multicolumn{1}{c}{\textbf{Uso en el proyecto}} \\
\midrule
JavaFX (controls, fxml, graphics) & 23.0.1 & Interfaz gráfica de la aplicación de escritorio (escenas, controles y carga de vistas FXML). \\
\hline
MySQL Connector & 9.5.0 & Conectividad JDBC con MySQL desde la aplicación desktop. \\
\hline
Argon2 JVM & 2.11 & Hash/verificación de contraseñas (almacenamiento seguro de credenciales). \\
\hline
Apache POI (poi, poi-ooxml) & 5.5.0 & Exportación de datos a ficheros Excel (XLSX). \\
\hline
Apache PDFBox & 2.0.30 & Generación/gestión de documentos PDF (p.\,ej., etiquetas o informes). \\
\hline
iText (itextpdf) & 5.5.13.3 & Generación de PDF (si se emplea en alguna parte del flujo documental). \\
\hline
ControlsFX & 11.1.0 & Controles UI adicionales para JavaFX (diálogos, validaciones visuales, etc.). \\
\hline
Ikonli (core, javafx, fontawesome-pack) & 12.2.0 & Iconografía en la interfaz JavaFX. \\
\hline
CalendarFX (view) & 11.10.1 & Vista de calendario para planificación/consulta de operaciones. \\
\bottomrule
\end{tabular}
\caption{Dependencias principales empleadas en la aplicación de escritorio.}
\label{tab:deps-desktop-principales}
\end{table}

La Figura~\ref{fig:arbol-directorio-logico-app-desktop} muestra el árbol de directorios correspondiente a la lógica principal de la aplicación situado en el paquete ``main''. En él se pueden observar los distintos paquetes que organizan las clases según su funcionalidad, tales como controladores de la intefaz gráfica \textit{controller}, modelos, acceso a datos y utilidades.


\DefineVerbatimEnvironment{Tree}{Verbatim}{
    fontsize=\small,
    baselinestretch=1,
    showspaces=false,
    showtabs=false
}

\begin{figure}[H]
    \centering
    \begin{Tree}
    └─── uvigo
        └─── tfgalmacen
            │    Main.java
            │    RutasFicheros.java
            │
            ├─── almacenManagement
            │        Almacen.java
            │        MisElementoGraficos.java
            │       ...
            ├─── controllers
            │   │    ajustesController.java
            │   │    almacenController.java
            │   │   ...
            │   │
            │   └─── apartadosAjustesControllers
            │            ItemEditarPedidoController.java
            │            ItemOrdenCrearPedidoController.java
            │           ...
            ├─── database
            │        ClientesDAO.java
            │        DatabaseConnection.java
            │      ...
            │
            ├─── gs1
            │        EtiquetaGS1.java
            │        GS1Utils.java
            │
            ├─── models
            │        Cliente.java
            │        OrdenCompra.java
            |       ...   
            │
            └─── utils
                     ClipboardUtils.java
                     ColorFormatter.java
                    ...
    \end{Tree}
    \caption{Árbol de directorios de la lógica de la app desktop}
    \label{fig:arbol-directorio-logico-app-desktop}
\end{figure}


Por otra parte, los recursos de interfaz se organizan en un paquete específico ``resources'' que agrupa los ficheros \gls{fxml}, junto con subdirectorios destinados a iconos e imágenes utilizados por las distintas vistas.

La Figura~\ref{fig:arbol-directorio-gui} muestra el árbol de directorios correspondiente a la interfaz gráfica de la aplicación, aquí tenemos todos los recursos gráficos como iconos, imagenes, que se emplearon en el diseño de la interfaz gráfica.

\begin{figure}[H]
    \centering
    \begin{Tree}
    ├─── icons
    │   │   󰸭 active-eye-24.png
    │   │   󰸭 add.png
    │   │   ...
    │   │
    │   ├─── arrows
    │   │       󰸭 icons8-arrow-left-30 (1).png
    │   │       󰸭 icons8-arrow-left-30.png
    │   │       ...
    │   │
    │   └─── barcodes
    │           󰸭 icons8-barcode-24 (1).png
    │           󰸭 icons8-barcode-24.png
    │           ...
    ├─── img
    │       󰸭dimensiones-pallet.png
    │       󰈥palet.jpg
    │       󰸭palet.PNG
    │
    └─── uvigo
        └─── tfgalmacen
            │   󰗀 apartadoAlmacen.fxml
            │   󰗀 apartadoCalendario.fxml
            │   ...
            │
            ├─── css
            │       buttons.css
            │       Colors.css
            │       ...
            │
            ├─── items
            │       󰗀 itemDetallesPedido.fxml
            │       󰗀 itemInventario.fxml
            │       ...
            │
            └─── ventanasAjustes
                ├─── ajustesPedidos
                │       󰗀 itemCrearPedido.fxml
                │       󰗀 itemEditarPedido.fxml
                │       ...
                │
                └─── ajustesUsuarios
                        󰗀 windowActualizarPedidoDeUsuarioEliminado.fxml
                        󰗀 windowAjustesCambiarContrasenaUsuarios.fxml
                        ...
    \end{Tree}
    \caption{Árbol de directorios de la interfaz gráfica}
    \label{fig:arbol-directorio-gui}
\end{figure}




\subsection{Implementación de la aplicación Android}
\label{subsec:impl-android}

La aplicación Android se ha desarrollado siguiendo el modelo de cliente ligero, delegando la lógica de negocio y la persistencia de datos en el backend del sistema. La implementación se basa en el uso de actividades para la gestión de las distintas pantallas y en el consumo de servicios REST mediante la librería Retrofit.

Las actividades principales gestionan flujos bien definidos, como la autenticación del usuario, la consulta de pedidos asignados y la modificación de información asociada a palets. El intercambio de información con el backend se realiza exclusivamente mediante objetos DTO, que representan contratos de datos desacoplados del modelo interno del servidor.

La autenticación se implementa mediante el envío de credenciales al backend, que valida el acceso y devuelve un token de sesión utilizado en las peticiones posteriores. Este token se gestiona en memoria durante la ejecución de la aplicación, evitando el almacenamiento persistente de información sensible en el dispositivo.


\begin{figure}[H]
\centering
\rotatebox{0}{%
  \includegraphics[width=0.8\textwidth]{../Diagramas-UML/login-android/login-android.png}%
}
\caption{Secuencia de autenticación en la aplicación Android}
\label{fig:login-android}
\end{figure}


El diseño de la interfaz prioriza la reducción de interacciones necesarias para completar una tarea. Las acciones más frecuentes, como actualización de cantidades, se implementan mediante formularios simplificados y selección asistida de datos, adaptados al uso en entornos operativos.

La aplicación Android restringe su funcionalidad al rol de operario, garantizando que únicamente se expongan operaciones relacionadas con la ejecución de pedidos y la gestión física de palets.

Las tecnologías empleadas en la implementación de la aplicación Android, la Tabla~\ref{tab:deps-android} recoge las dependencias principales utilizadas, junto con su versión y su función dentro del proyecto.


\begin{table}[H]
\centering
\small
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{m{4.6cm} m{2.2cm} m{7.2cm}}
\hline
\rowcolor{gray!15}
\multicolumn{1}{c}{\textbf{Componente}} &
\multicolumn{1}{c}{\textbf{Versión}} &
\multicolumn{1}{c}{\textbf{Uso en el proyecto}} \\
\hline
AndroidX AppCompat & 1.7.1 &
Compatibilidad con versiones modernas de Android y soporte de componentes base de interfaz. \\
\hline
Material Components & 1.13.0 &
Implementación de elementos de interfaz siguiendo las guías de diseño Material Design. \\
\hline
AndroidX Activity & 1.12.0 &
Gestión del ciclo de vida de las \emph{activities} y comunicación con la interfaz. \\
\hline
ConstraintLayout & 2.2.1 &
Diseño flexible y eficiente de las pantallas mediante restricciones entre componentes. \\
\hline
Retrofit & 3.0.0 &
Cliente HTTP para el consumo de la API REST desde la aplicación Android. \\
\hline
Retrofit Gson Converter & 3.0.0 &
Serialización y deserialización automática de mensajes JSON intercambiados con la API. \\
\hline
\end{tabular}
\caption{Dependencias principales y versiones de la aplicación Android.}
\label{tab:deps-android}
\end{table}

El código se organiza en cuatro bloques: activities'' controla la interfaz y el flujo inicial, incluyendo validaciones y acciones; api'' gestiona la comunicación externa con Retrofit para enviar y recibir datos de palets y pedidos; models'' define los DTO para estructurar la información; y adapters'' convierte esos modelos en elementos de las listas dinámicas de la interfaz, cerrando el ciclo de visualización y respuesta a eventos. La Figura~\ref{fig:arbol-directorio-app-android} muestra el árbol de directorios de la aplicación.



\begin{figure}[H]
    \centering
    \begin{Tree}
         java        
        │    LoginRequest.java
        │    LoginResponse.java
        │
        ├─── activities
        │        EditPaletActivity.java
        │        LoginActivity.java
        │       ...
        │
        ├─── adapters
        │        OnProductoActionListener.java
        │        PedidosAdapter.java
        │        ProductosAdapter.java
        │
        ├─── api
        │        ApiClient.java
        │        AuthApi.java
        │       ...
        │
        └─── models
                 CambiarEstadoPedidoDto.java
                 CambiarEstadoProductoDto.java
                ...
    \end{Tree}
    \caption{Árbol de directorios del paquete de la app Android}
    \label{fig:arbol-directorio-app-android}
\end{figure}

Para la intefaz gráfica, se utilizan ficheros XML que definen la estructura visual de cada pantalla, así como los diferentes iconos e imagenes implementadas en la aplicación. La Figura~\ref{fig:arbol-directorio-interfaz-android} muestra el árbol de directorios correspondiente a los recursos gráficos de la aplicación Android.

\begin{figure}[H]
    \centering
    \begin{Tree}
         res
        ├─── drawable
        │       󰗀 borde_blanco.xml
        │       󰗀 button_orange.xml
        │       ...
        │
        ├─── layout
        │       󰗀 activity_edit_palet.xml
        │       󰗀 activity_login.xml
        │       󰗀 activity_main.xml
        │       󰗀 activity_pedido.xml
        │       󰗀 activity_select_options.xml
        │       󰗀 item_pedidos.xml
        │       󰗀 item_productos_pendientes.xml
        │
        ├─── values
        │       󰗀 colors.xml
        │       󰗀 strings.xml
        │       󰗀 themes.xml
        │
        ├─── values-night
        │       󰗀 themes.xml
        │
        └─── ...
    \end{Tree}
    \caption{Árbol de directorios de los recursos gráficos de la app Android}
    \label{fig:arbol-directorio-interfaz-android}
\end{figure}

\subsection{Implementación del backend / servidor}
\label{subsec:impl-backend}

El backend del sistema se ha desarrollado como una API REST basada en Spring Boot. Esta tecnologia ha sido seleccionada por ser el framework más popular en el ecosistema Java, ofreciendo una amplia gama de funcionalidades integradas y una comunidad activa que facilita la resolución de problemas y la incorporación de buenas prácticas.

La \gls{api} Spring Boot desarrollada está estructurada en capas bien definidas que separan la exposición de servicios, la lógica de negocio y el acceso a datos. Esta organización facilita el mantenimiento del código, la evolución funcional y la validación de reglas de negocio de forma centralizada.

La capa de controladores, define los endpoints HTTP de la API y actúa como punto de entrada para las peticiones de los clientes. En esta capa se realiza la validación inicial de los datos recibidos y la conversión entre los objetos de transferencia (DTOs) y el modelo interno del sistema. Asimismo, los controladores construyen las respuestas HTTP, devolviendo códigos de estado coherentes con el resultado de cada operación (por ejemplo, éxito, error de validación o recurso no encontrado).

La lógica de negocio se concentra en la capa de servicios, donde se implementan las reglas funcionales del sistema. Esta capa coordina las operaciones sobre los repositorios y garantiza la coherencia del dominio, aplicando comprobaciones como la validez del estado de un pedido antes de su modificación o la detección de conflictos en la asignación de ubicaciones de palets. Las operaciones que implican cambios persistentes se ejecutan dentro de transacciones para asegurar la consistencia de los datos ante fallos o accesos concurrentes.

El acceso a la base de datos se realiza mediante Spring Data JPA. Este enfoque permite disponer de operaciones CRUD estándar y de consultas derivadas por nombre o personalizadas, empleadas para validar condiciones específicas, como la existencia previa de registros o la verificación de restricciones operativas antes de una actualización.

El backend incorpora también mecanismos de seguridad y control de errores. La autenticación de usuarios se apoya en credenciales almacenadas de forma segura y en la validación centralizada de accesos a los endpoints. El tratamiento de excepciones se unifica mediante un componente global que traduce errores de dominio y validación en respuestas HTTP normalizadas, garantizando un comportamiento consistente frente a situaciones anómalas para la aplicación móvil.

En la implementación del backend se emplearon diversas tecnologías; la Tabla~\ref{tab:deps-backend} recoge las dependencias principales utilizadas, junto con su versión y su función dentro del proyecto.

\begin{table}[H]
\centering
\small
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{m{4.2cm} m{2.2cm} m{7.6cm}}
\hline
\rowcolor{gray!15}
\multicolumn{1}{c}{\textbf{Componente}} &
\multicolumn{1}{c}{\textbf{Versión}} &
\multicolumn{1}{c}{\textbf{Uso en el proyecto}} \\
\hline
Framework backend & 4.0.0 & Estructura base del backend y gestión del ciclo de vida de la aplicación \\
\hline
API REST (Web MVC) & 4.0.0 & Exposición de endpoints HTTP y controladores REST \\
\hline
Persistencia (JPA) & 4.0.0 & Abstracción del acceso a datos mediante repositorios \\
\hline
ORM & 7.1.8 & Mapeo objeto-relacional entre entidades Java y tablas MySQL \\
\hline
Pool de conexiones JDBC & 7.0.2 & Gestión eficiente de conexiones a la base de datos \\
\hline
Driver MySQL & 9.5.0 & Comunicación JDBC entre la aplicación y MySQL \\
\hline
Hash de contraseñas (Argon2) & 2.11 & Almacenamiento seguro de credenciales de usuario \\
\hline
Servidor embebido & 4.0.0 & Ejecución autónoma de la API sin servidor externo \\
\hline
Servlet container (Tomcat) & 11.0.14 & Gestión de peticiones HTTP y ciclo de servlets \\
\hline

\end{tabular}
\caption{Dependencias principales, versiones y uso en el backend (API REST).}
\label{tab:deps-backend}
\end{table}


\subsection{Implementación de la base de datos}
\label{subsec:impl-bd}

La base de datos del sistema se ha implementado sobre un sistema gestor relacional MySQL, seleccionado por su madurez, estabilidad y compatibilidad con entornos de producción y herramientas de desarrollo ampliamente utilizadas como \textit{MySQL Workbench}. El esquema se define mediante scripts \gls{sql} que crean las tablas, claves primarias, claves foráneas y restricciones necesarias para garantizar la integridad de los datos. Ver el Anexo~\ref{anexo:sql-esquema} para consultar el script completo de creación de la base de datos.

Las relaciones entre entidades se refuerzan mediante restricciones \texttt{FOREIGN KEY}, que controlan dependencias como la asociación entre palets y ubicaciones o entre pedidos y productos. Se han definido índices sobre campos de búsqueda frecuente, como identificadores de usuario, códigos de palet y estados de pedido, con el objetivo de optimizar las consultas más habituales.

También se han automatizado ciertas operaciones mediante \texttt{TRIGGERS} que garantizan la coherencia de datos y su trazabilidad. Uno de estos  \texttt{TRIGGERS} lo implemntamos para la generación automática de códigos para nuevos pedidos. El siguiente código (Figura~\ref{fig:trigger-ejemplo}) muestra un trigger que asigna un código único a cada nuevo pedido insertado en la base de datos:

\begin{figure}[H]
    \centering
    \lstinputlisting[language=SQL]{Codigo/trigger-ejemplo.sql}
    \caption{Trigger para asignar código único a nuevos pedidos}
    \label{fig:trigger-ejemplo}
\end{figure}


La gestión de usuarios incluye el almacenamiento seguro de credenciales, la seguridad de las credenciales se detalla en la sección siguiente. Las contraseñas no se guardan en texto plano, sino como valores ilegibles. Esta implementación protege las credenciales frente a ataques de fuerza bruta y accesos no autorizados.

Para facilitar la puesta en marcha y las pruebas del sistema, el esquema incluye datos iniciales, como roles, permisos y configuraciones básicas del almacén (información obtenida del cliente), que permiten validar el funcionamiento completo de la aplicación desde las primeras fases de ejecución.

\subsubsection{Generación de códigos de referencia automáticos}

En la base de datos se ha implementado un mecanismo automático para la generación de códigos únicos de referencia para los pedidos y para las ordenes de compra. Este sistema asegura que cada elemento recibe un identificador distinto, que proporciona informacion acerca de este, en particular este código permite identificar el tipo de operación mediante un prefijo y cuando fue creado.

\begin{center}
\texttt{PREFIX-YYYYMMDD-HHHHHH}
\end{center}

Para los pedidos, el prefijo utilizado es \texttt{PED}, mientras que para las ordenes de compra se emplea el prefijo \texttt{OC}.

El campo \texttt{YYYYMMDD} corresponde a la fecha de creación del pedido y \texttt{HHHHHH} es un contador secuencial diario expresado en formato hexadecimal. Este mecanismo permite generar hasta $16^6$ identificadores únicos por día, garantizando unicidad sin depender de la intervención del cliente y facilitando la trazabilidad temporal de los pedidos.

Como se ha mencionado anteriormente, este sistema de generación automática de códigos se implementa mediante un \texttt{TRIGGER} en la base de datos que se activa al insertar un nuevo registro en la tabla correspondiente.

Un ejemplo de esto lo encontramos en la Figura~\ref{fig:trigger-ejemplo}, donde se genera el codigo de los pedidos PED-YYYYMMDD-HHHHHH.



\subsection{Generación de etiquetas GS1}
\label{subsec:impl-gs1}

El sistema incorpora un mecanismo de generación de etiquetas normalizadas para la identificación de palets y productos, basado en el estándar GS1. Este estándar se emplea de forma habitual en entornos logísticos e industriales para garantizar la interoperabilidad, la trazabilidad de los materiales y la lectura automatizada mediante códigos de barras \footweb{gs1_general}.

La generación de etiquetas se implementa en la aplicación de escritorio, integrándose dentro del flujo operativo del almacén. Las etiquetas se producen en formato PDF y se almacenan localmente en el ordenador donde se generan.

Desde el punto de vista técnico, la generación de la etiqueta se encapsula en un módulo específico de la aplicación, encargado de construir el contenido GS1 a partir de los datos del modelo y de generar el documento PDF correspondiente. Este enfoque permite aislar la lógica de generación de etiquetas del resto de la aplicación y facilita su mantenimiento o adaptación futura a otros formatos o estándares.

Como mecanismos de seguridad el sistema no permite marcar un pedido como \texttt{ENVIADO} si la etiqueta no ha sido generada previamente.

\begin{figure}[H]
    \centering
    \setlength{\fboxsep}{0pt} % Elimina el espacio entre el borde y la imagen
    \setlength{\fboxrule}{0.2pt} % Ajusta el grosor del borde
    \fbox{\includegraphics[width=0.7\textwidth]{Imagenes/etiqueta-gs1-ejemplo.pdf}}
    \caption{Ejemplo de etiqueta GS1 generada por el sistema}
    \label{fig:etiqueta-gs1}
\end{figure}

La generación del codigo de barras se realiza mediante identificadores de aplicación definidos por el sistema GS1 \footweb{gs1_application_identifiers}, estos identificadores dependen de los productos que contenga el palet a enviar, por tanto, dependiendo de las necesidades del cliente habrá que adaptarlos.


\textbf{NOTA}: El objetivo de este proyecto no es la generación completa de etiquetas GS1, sino la integración de un mecanismo que permita su creación siguiendo el estándar. La Figura~\ref{fig:etiqueta-gs1} muestra un ejemplo de etiqueta generada por el sistema, que incluye los elementos básicos definidos por GS1, como el código de barras, el identificador del producto y la información relevante para la gestión logística. La configuración de la etiqueta deberá adaptarse a las necesidades específicas del cliente.

\subsection{Seguridad y gestión de errores}
\label{subsec:seguridad-errores}

El sistema incorpora mecanismos específicos para la protección de las credenciales de los usuarios y la gestión controlada de errores. Las contraseñas no se almacenan en texto claro en la base de datos, sino que se transforman mediante un algoritmo de derivación de claves diseñado para entornos de autenticación, evitando que la exposición de la base de datos implique la divulgación directa de credenciales.

Para este propósito se ha utilizado Argon2, un algoritmo moderno orientado al almacenamiento seguro de contraseñas. Este algoritmo permite incrementar el coste computacional del proceso de verificación, dificultando ataques de fuerza bruta. Su diseño prioriza el consumo controlado de recursos, lo que refuerza la seguridad sin afectar de forma significativa al uso normal del sistema.

La verificación de credenciales se realiza siempre comparando el valor derivado de la contraseña introducida con el hash almacenado, sin necesidad de revertir el proceso. De este modo, la lógica de autenticación mantiene una separación clara entre los datos sensibles y el resto de la aplicación, reduciendo la superficie de ataque y alineándose con buenas prácticas de seguridad en
sistemas de información.

